package codegen

import (
    "fmt"
    "strings"
    "codeberg.org/clockwise-lang/clockwise/parser"
)

// Generate produces Go source for the given program. The CLI will write this
// into a temporary module along with the runtime Go file and run `go build`.
func Generate(p *parser.Program) string {
    var sb strings.Builder
    sb.WriteString("// Generated by Clockwise transpiler\n")
    sb.WriteString("package main\n\n")
    sb.WriteString("import (\n\t\"fmt\"\n)\n\n")

    for _, fn := range p.Functions {
        cRet := "int"
        if fn.ReturnType != "" {
            cRet = mapType(fn.ReturnType)
        }
        if fn.Name == "main" {
            sb.WriteString(fmt.Sprintf("func main() %s {\n", cRet))
            for _, st := range fn.Body.Statements {
                sb.WriteString(genStatement(st))
            }
            sb.WriteString("}\n\n")
            continue
        }
        sb.WriteString(fmt.Sprintf("func %s() %s {\n", fn.Name, cRet))
        for _, st := range fn.Body.Statements {
            sb.WriteString(genStatement(st))
        }
        sb.WriteString("}\n\n")
    }

    return sb.String()
}

func genStatement(s parser.Statement) string {
    switch st := s.(type) {
    case *parser.ReturnStatement:
        return fmt.Sprintf("return %s\n", genExpr(st.Value))
    case *parser.ExpressionStatement:
        return fmt.Sprintf("%s\n", genExpr(st.Expr))
    case *parser.VarStatement:
        ctype := mapType(st.Type)
        return fmt.Sprintf("var %s %s = %s\n", st.Name, ctype, genExpr(st.Value))
    default:
        return "// unsupported stmt\n"
    }
}

func genExpr(e parser.Expression) string {
    switch ex := e.(type) {
    case *parser.IntegerLiteral:
        return ex.Value
    case *parser.StringLiteral:
        esc := EscapeString(ex.Value)
        return fmt.Sprintf("\"%s\"", esc)
    case *parser.Identifier:
        return ex.Value
    case *parser.CallExpression:
        if id, ok := ex.Function.(*parser.Identifier); ok {
            fname := id.Value
            if fname == "print" {
                if len(ex.Args) == 1 {
                    return fmt.Sprintf("Print(%s)", genExpr(ex.Args[0]))
                }
            }
            var args []string
            for _, a := range ex.Args {
                args = append(args, genExpr(a))
            }
            return fmt.Sprintf("%s(%s)", fname, strings.Join(args, ", "))
        }
        return "/* unsupported call */"
    case *parser.InfixExpression:
        return fmt.Sprintf("(%s %s %s)", genExpr(ex.Left), ex.Operator, genExpr(ex.Right))
    default:
        return "0"
    }
}

func mapType(t string) string {
    switch t {
    case "int":
        return "int"
    case "string":
        return "string"
    default:
        return "int"
    }
}
